---
title: javascript词法作用域
date: 2018-06-07
category: js
comment: true
---
### 词法作用域

js代码编译过程第一阶段是词法化，而在词法化过程就定义好的作用域就是词法作用域。词法作用域就是定义在词法阶段的作用域。所以词法作用域在写代码时就决定了所处的作用域，当词法分析器处理代码时会保持作用域不变，但有些方法可以欺骗词法作用域。

1. js作用域变量查找规则：
    - 代码执行前，进行变量的申明
    - 查找当前作用域的变量，如果有申明，则读取，如果没有申明，则往外层作用于继续查找，一直到全局用域还没找到，则返回undefined。多级作用域的查找也就形成了作用域的嵌套。

2. ES5作用域的生成     
在ES5中，只存在全局作用域和函数作用域。全局作用域是在代码运行时就会生成的作用域。函数作用域则是在定义函数时生成的作用域。
```js
function a() {
    //...
}
```

3. 变量提升和函数提升问题
js其实是编译型语言，在代码执行前，会将变量的申明和函数的申明提升至作用域的最开始部分。这就是变量提升。
```js
var a = 1;
function f() {
    console.log(a);//undefined
    var a = 2;
}
f();
``` 
上面代码执行打印的结果是undefined。通过变量提升和变量作用域查找规则分析，在函数f的作用域中，会将变量a的申明提升至函数的顶部，执行console.log(a)的打印时，找到了申明的a变量，但是没有赋值。在函数作用域内找到了变量所以不会往外层作用域查找。所以值是undefined。其效果相当域下面一段代码
```js
var a = 1;
function f() {
    var a;
    console.log();
    a = 2;
}
f();
```
函数创建方式由两种，函数申明式和函数字面量式，但是只有函数申明式才存在变量提升。       
```js
console.log(a);//funcotin a(){}
console.log(b);//undefined
function a() {
    //..
}
var b = function () {

}
```

4. ES6 引入的块级作用域和块级变量let
ES6引入了{}的块级作用域，在块中申明的变量只用块内才有效。同时let不会有变量提升问题
```js
{
    var a = 1;
    let b = 2;
}
console.log(a);//1
console.log(b);//Uncaught ReferenceError: b is not defined
```
同时有个比较经典的在闭包问题中常举地例子
```js
for(var i = 0; i < 10; i++) {
    setTimeout(()=>{
        console.log(i);
    })
}
//打印 10个 10
```
这段代码涉及两个主要问题。
- var申明的i变量是函数作用域共用的，所以第二次循环i的值就变了。
- js事件循环问题，setTimeout将callback放入事件循环中，等到循环代码执行结束，才执行setTimout中地回调。       

所以到当执行console.log回调时，i变量值已经是10。       
在闭包问题中，通过生成闭包函数记住每次循环的变量值可以解决问题。
```js
for(var i = 0; i < 10; i++) {
    ((i) => {
        setTimeout(()=>{
            console.log(i);
        })
    })(i)
}
//打印 1 2 3 4 ... 9
```
每次循环都会通过一个自执行函数生成一个函数作用域，每个函数作用域都可以记住其接受的变量值i。 而通过ES6的let块级变量，也可以解决此问题。
```js
for(let i = 0; i < 10; i++) {
    setTimeout(()=>{
        console.log(i);
    })
}
//打印 1 2 3 4 ... 9
```  
每次循环let都会生成一个作用域，每次循环的i值都保存在对应的作用域中，所以在执行console.log时，能够找到每次循环的作用域找到该值i。


### 参考

《你不知道的javascript（上卷）》
